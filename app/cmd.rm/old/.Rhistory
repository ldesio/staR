source(file=script)
retVal <- paste(retVal,readChar(script, file.info(script)$size),sep="\n")
# calls the function
# eval(parse(text=paste(command,"(cmd)")))
if (exists("cmd$ifclause")) {
if (cmd$ifclause != "") {
detach()
attach(star.data)
}
}
} else {
return(theLine)
}
} else {
return(theLine)
}
return(retVal)
}
source <- star.source(star.cmdline)
source
#eval(parse(text=source))
source(file="./_star_lib.R")
star.cmdline <- "regress depvar indepvar"
theLine <- "regress depvar indepvar"
star.source <- function(theLine) {
if (grepl(" ",theLine)) {
pos_firstspace <- regexpr (' ',theLine)
command <- substring(theLine,1,pos_firstspace-1)
script <- paste("cmd/",command,".r",sep="")
if (file.exists(script)) {
# read lines of script file
x <- scan(script, what="", sep="\n")
# assumes first line contains a "syntax" clause
syntaxrow <- x[1]
# loads content of "syntax" clause: everything after the "syntax" keyword
syntaxspec <- substring(syntaxrow,regexpr (' ',syntaxrow)+1)
# uses such "syntax" clause spec, to correctly parse the received Stata command line,
#	and appropriately populates the "cmd" object
thiscmd <- paste("cmd <- star_parse_stata_command(\"",syntaxspec,"\")",sep="",collapse="")
retVal <- paste(retVal,thiscmd,sep="\n")
cmd <- star_parse_stata_command(syntaxspec)
# HTML.title("****",HR=2)
if (FALSE) {
if (exists("cmd$ifclause")) {
if (cmd$ifclause != "") {
detach(star.data)
# no math operators (including < >) on factors.
# Should list all involved vars and convert them to copies, using as.numeric(levels(f))[f]
fz <- factorsNumeric(star.data)
sel <- fz[which(eval(parse(text=cmd$ifclause)))]
HTML.title(fz, HR=2)
HTML.title(sel,HR=2)
#attach(subset(star.data,eval(parse(text=cmd$ifclause))))
attach(star.data[sel])
}
}
}
# loads the script file, so that the function becomes available
source(file=script)
retVal <- paste(retVal,readChar(script, file.info(script)$size),sep="\n")
# calls the function
# eval(parse(text=paste(command,"(cmd)")))
if (exists("cmd$ifclause")) {
if (cmd$ifclause != "") {
detach()
attach(star.data)
}
}
} else {
return(theLine)
}
} else {
return(theLine)
}
return(retVal)
}
source <- star.source(star.cmdline)
source
#eval(parse(text=source))
source(file="./_star_lib.R")
star.cmdline <- "regress depvar indepvar"
theLine <- "regress depvar indepvar"
star.source <- function(theLine) {
if (grepl(" ",theLine)) {
pos_firstspace <- regexpr (' ',theLine)
command <- substring(theLine,1,pos_firstspace-1)
script <- paste("cmd/",command,".r",sep="")
if (file.exists(script)) {
# read lines of script file
x <- scan(script, what="", sep="\n")
# assumes first line contains a "syntax" clause
syntaxrow <- x[1]
# loads content of "syntax" clause: everything after the "syntax" keyword
syntaxspec <- substring(syntaxrow,regexpr (' ',syntaxrow)+1)
# uses such "syntax" clause spec, to correctly parse the received Stata command line,
#	and appropriately populates the "cmd" object
thiscmd <- paste("cmd <- star_parse_stata_command(\"",syntaxspec,"\")",sep="",collapse="")
retVal <- paste(retVal,thiscmd,sep="\n")
cmd <- star_parse_stata_command(syntaxspec)
# HTML.title("****",HR=2)
if (FALSE) { # applies IF clause
if (exists("cmd$ifclause")) {
if (cmd$ifclause != "") {
detach(star.data)
# no math operators (including < >) on factors.
# Should list all involved vars and convert them to copies, using as.numeric(levels(f))[f]
fz <- factorsNumeric(star.data)
sel <- fz[which(eval(parse(text=cmd$ifclause)))]
HTML.title(fz, HR=2)
HTML.title(sel,HR=2)
#attach(subset(star.data,eval(parse(text=cmd$ifclause))))
attach(star.data[sel])
}
}
}
# loads the script file, so that the function becomes available
source(file=script)
retVal <- paste(retVal,readChar(script, file.info(script)$size),sep="\n")
# calls the function
# eval(parse(text=paste(command,"(cmd)")))
if (exists("cmd$ifclause")) {
if (cmd$ifclause != "") {
detach()
attach(star.data)
}
}
} else {
return(theLine)
}
return(retVal)
} else {
return(theLine)
}
return(theLine)
}
source <- star.source(star.cmdline)
source
#eval(parse(text=source))
star.source("regress depvar indepvar")
debugSource('M:/staR/_ws/staR/cmd/_dispatcher.new.r')
debugSource('M:/staR/_ws/staR/cmd/_dispatcher.new.r')
star.source("regress depvar indepvar")
script <- paste("./",command,".r",sep="")
star.source <- function(theLine) {
debugSource('M:/staR/_ws/staR/cmd/_dispatcher.new.r')
script <- paste("./",command,".r",sep="")
if (file.exists(script)) {
debugSource('M:/staR/_ws/staR/cmd/_dispatcher.new.r')
debugSource('M:/staR/_ws/staR/cmd/_dispatcher.new.r')
debugSource('M:/staR/_ws/staR/cmd/_dispatcher.new.r')
debugSource('M:/staR/_ws/staR/cmd/_dispatcher.new.r')
debugSource('M:/staR/_ws/staR/cmd/_dispatcher.new.r', echo=TRUE)
source(file="./_star_lib.R")
star.cmdline <- "regress depvar indepvar"
theLine <- star.cmdline
star.source <- function(theLine) {
if (grepl(" ",theLine)) {
pos_firstspace <- regexpr (' ',theLine)
command <- substring(theLine,1,pos_firstspace-1)
script <- paste("./",command,".r",sep="")
if (file.exists(script)) {
# read lines of script file
x <- scan(script, what="", sep="\n")
# assumes first line contains a "syntax" clause
syntaxrow <- x[1]
# loads content of "syntax" clause: everything after the "syntax" keyword
syntaxspec <- substring(syntaxrow,regexpr (' ',syntaxrow)+1)
# uses such "syntax" clause spec, to correctly parse the received Stata command line,
#	and appropriately populates the "cmd" object
thiscmd <- paste("cmd <- star_parse_stata_command(\"",syntaxspec,"\")",sep="",collapse="")
retVal <- paste(retVal,thiscmd,sep="\n")
cmd <- star_parse_stata_command(syntaxspec)
# HTML.title("****",HR=2)
if (FALSE) { # applies IF clause
if (exists("cmd$ifclause")) {
if (cmd$ifclause != "") {
detach(star.data)
# no math operators (including < >) on factors.
# Should list all involved vars and convert them to copies, using as.numeric(levels(f))[f]
fz <- factorsNumeric(star.data)
sel <- fz[which(eval(parse(text=cmd$ifclause)))]
HTML.title(fz, HR=2)
HTML.title(sel,HR=2)
#attach(subset(star.data,eval(parse(text=cmd$ifclause))))
attach(star.data[sel])
}
}
}
# loads the script file, so that the function becomes available
source(file=script)
retVal <- paste(retVal,readChar(script, file.info(script)$size),sep="\n")
# calls the function
# eval(parse(text=paste(command,"(cmd)")))
if (exists("cmd$ifclause")) {
if (cmd$ifclause != "") {
detach()
attach(star.data)
}
}
} else {
return(theLine)
}
return(retVal)
} else {
return(theLine)
}
return(theLine)
}
source <- star.source(star.cmdline)
source
#eval(parse(text=source))
source(file="./_star_lib.R")
star.cmdline <- "regress depvar indepvar"
theLine <- star.cmdline
star.source <- function(theLine) {
if (grepl(" ",theLine)) {
pos_firstspace <- regexpr (' ',theLine)
command <- substring(theLine,1,pos_firstspace-1)
script <- paste("./",command,".r",sep="")
if (file.exists(script)) {
# read lines of script file
x <- scan(script, what="", sep="\n")
# assumes first line contains a "syntax" clause
syntaxrow <- x[1]
# loads content of "syntax" clause: everything after the "syntax" keyword
syntaxspec <- substring(syntaxrow,regexpr (' ',syntaxrow)+1)
# uses such "syntax" clause spec, to correctly parse the received Stata command line,
#	and appropriately populates the "cmd" object
thiscmd <- paste("cmd <- star_parse_stata_command(\"",syntaxspec,"\")",sep="",collapse="")
retVal <- paste(retVal,thiscmd,sep="\n")
cmd <- star_parse_stata_command(syntaxspec)
# HTML.title("****",HR=2)
if (FALSE) { # applies IF clause
if (exists("cmd$ifclause")) {
if (cmd$ifclause != "") {
detach(star.data)
# no math operators (including < >) on factors.
# Should list all involved vars and convert them to copies, using as.numeric(levels(f))[f]
fz <- factorsNumeric(star.data)
sel <- fz[which(eval(parse(text=cmd$ifclause)))]
HTML.title(fz, HR=2)
HTML.title(sel,HR=2)
#attach(subset(star.data,eval(parse(text=cmd$ifclause))))
attach(star.data[sel])
}
}
}
# loads the script file, so that the function becomes available
source(file=script)
retVal <- paste(retVal,readChar(script, file.info(script)$size),sep="\n")
# calls the function
# eval(parse(text=paste(command,"(cmd)")))
if (exists("cmd$ifclause")) {
if (cmd$ifclause != "") {
detach()
attach(star.data)
}
}
} else {
return(theLine)
}
return(retVal)
} else {
return(theLine)
}
return(theLine)
}
source <- star.source(star.cmdline)
source
#eval(parse(text=source))
source(file="./_star_lib.R")
star.cmdline <- "regress depvar indepvar"
theLine <- star.cmdline
star.source <- function(theLine) {
if (grepl(" ",theLine)) {
pos_firstspace <- regexpr (' ',theLine)
command <- substring(theLine,1,pos_firstspace-1)
script <- paste("./",command,".r",sep="")
retVal <- ""
if (file.exists(script)) {
# read lines of script file
x <- scan(script, what="", sep="\n")
# assumes first line contains a "syntax" clause
syntaxrow <- x[1]
# loads content of "syntax" clause: everything after the "syntax" keyword
syntaxspec <- substring(syntaxrow,regexpr (' ',syntaxrow)+1)
# uses such "syntax" clause spec, to correctly parse the received Stata command line,
#	and appropriately populates the "cmd" object
thiscmd <- paste("cmd <- star_parse_stata_command(\"",syntaxspec,"\")",sep="",collapse="")
retVal <- paste(retVal,thiscmd,sep="\n")
cmd <- star_parse_stata_command(syntaxspec)
# HTML.title("****",HR=2)
if (FALSE) { # applies IF clause
if (exists("cmd$ifclause")) {
if (cmd$ifclause != "") {
detach(star.data)
# no math operators (including < >) on factors.
# Should list all involved vars and convert them to copies, using as.numeric(levels(f))[f]
fz <- factorsNumeric(star.data)
sel <- fz[which(eval(parse(text=cmd$ifclause)))]
HTML.title(fz, HR=2)
HTML.title(sel,HR=2)
#attach(subset(star.data,eval(parse(text=cmd$ifclause))))
attach(star.data[sel])
}
}
}
# loads the script file, so that the function becomes available
source(file=script)
retVal <- paste(retVal,readChar(script, file.info(script)$size),sep="\n")
# calls the function
# eval(parse(text=paste(command,"(cmd)")))
if (exists("cmd$ifclause")) {
if (cmd$ifclause != "") {
detach()
attach(star.data)
}
}
} else {
return(theLine)
}
return(retVal)
} else {
return(theLine)
}
return(theLine)
}
source <- star.source(star.cmdline)
source
#eval(parse(text=source))
source(file="./_star_lib.R")
star.cmdline <- "regress depvar indepvar"
theLine <- star.cmdline
star.source <- function(theLine) {
if (grepl(" ",theLine)) {
pos_firstspace <- regexpr (' ',theLine)
command <- substring(theLine,1,pos_firstspace-1)
script <- paste("./",command,".r",sep="")
retVal <- ""
if (file.exists(script)) {
# read lines of script file
x <- scan(script, what="", sep="\n")
# assumes first line contains a "syntax" clause
syntaxrow <- x[1]
# loads content of "syntax" clause: everything after the "syntax" keyword
syntaxspec <- substring(syntaxrow,regexpr (' ',syntaxrow)+1)
# uses such "syntax" clause spec, to correctly parse the received Stata command line,
#	and appropriately populates the "cmd" object
thiscmd <- paste("cmd <- star_parse_stata_command(\"",syntaxspec,"\")",sep="",collapse="")
retVal <- paste(retVal,thiscmd,sep="\n")
cmd <<- star_parse_stata_command(syntaxspec)
# HTML.title("****",HR=2)
if (FALSE) { # applies IF clause
if (exists("cmd$ifclause")) {
if (cmd$ifclause != "") {
detach(star.data)
# no math operators (including < >) on factors.
# Should list all involved vars and convert them to copies, using as.numeric(levels(f))[f]
fz <- factorsNumeric(star.data)
sel <- fz[which(eval(parse(text=cmd$ifclause)))]
HTML.title(fz, HR=2)
HTML.title(sel,HR=2)
#attach(subset(star.data,eval(parse(text=cmd$ifclause))))
attach(star.data[sel])
}
}
}
# loads the script file, so that the function becomes available
source(file=script)
retVal <- paste(retVal,readChar(script, file.info(script)$size),sep="\n")
# calls the function
# eval(parse(text=paste(command,"(cmd)")))
if (exists("cmd$ifclause")) {
if (cmd$ifclause != "") {
detach()
attach(star.data)
}
}
} else {
return(theLine)
}
return(retVal)
} else {
return(theLine)
}
return(theLine)
}
source <- star.source(star.cmdline)
source
#eval(parse(text=source))
source(file="./_star_lib.R")
star.cmdline <- "regress depvar indepvar"
theLine <- star.cmdline
library("R2HTML")
star.source <- function(theLine) {
if (grepl(" ",theLine)) {
pos_firstspace <- regexpr (' ',theLine)
command <- substring(theLine,1,pos_firstspace-1)
script <- paste("./",command,".r",sep="")
retVal <- ""
if (file.exists(script)) {
# read lines of script file
x <- scan(script, what="", sep="\n")
# assumes first line contains a "syntax" clause
syntaxrow <- x[1]
# loads content of "syntax" clause: everything after the "syntax" keyword
syntaxspec <- substring(syntaxrow,regexpr (' ',syntaxrow)+1)
# uses such "syntax" clause spec, to correctly parse the received Stata command line,
#	and appropriately populates the "cmd" object
thiscmd <- paste("cmd <- star_parse_stata_command(\"",syntaxspec,"\")",sep="",collapse="")
retVal <- paste(retVal,thiscmd,sep="\n")
cmd <<- star_parse_stata_command(syntaxspec)
# HTML.title("****",HR=2)
if (FALSE) { # applies IF clause
if (exists("cmd$ifclause")) {
if (cmd$ifclause != "") {
detach(star.data)
# no math operators (including < >) on factors.
# Should list all involved vars and convert them to copies, using as.numeric(levels(f))[f]
fz <- factorsNumeric(star.data)
sel <- fz[which(eval(parse(text=cmd$ifclause)))]
HTML.title(fz, HR=2)
HTML.title(sel,HR=2)
#attach(subset(star.data,eval(parse(text=cmd$ifclause))))
attach(star.data[sel])
}
}
}
# loads the script file, so that the function becomes available
source(file=script)
retVal <- paste(retVal,readChar(script, file.info(script)$size),sep="\n")
# calls the function
# eval(parse(text=paste(command,"(cmd)")))
if (exists("cmd$ifclause")) {
if (cmd$ifclause != "") {
detach()
attach(star.data)
}
}
} else {
return(theLine)
}
return(retVal)
} else {
return(theLine)
}
return(theLine)
}
source <- star.source(star.cmdline)
source
#eval(parse(text=source))
source(file="./_star_lib.R")
star.cmdline <- "regress depvar indepvar"
theLine <- star.cmdline
#library("R2HTML")
star.source <- function(theLine) {
if (grepl(" ",theLine)) {
pos_firstspace <- regexpr (' ',theLine)
command <- substring(theLine,1,pos_firstspace-1)
script <- paste("./",command,".r",sep="")
retVal <- ""
if (file.exists(script)) {
# read lines of script file
x <- scan(script, what="", sep="\n")
# assumes first line contains a "syntax" clause
syntaxrow <- x[1]
# loads content of "syntax" clause: everything after the "syntax" keyword
syntaxspec <- substring(syntaxrow,regexpr (' ',syntaxrow)+1)
# uses such "syntax" clause spec, to correctly parse the received Stata command line,
#	and appropriately populates the "cmd" object
thiscmd <- paste("cmd <- star_parse_stata_command(\"",syntaxspec,"\")",sep="",collapse="")
retVal <- paste(retVal,thiscmd,sep="\n")
cmd <<- star_parse_stata_command(syntaxspec)
# HTML.title("****",HR=2)
if (FALSE) { # applies IF clause
if (exists("cmd$ifclause")) {
if (cmd$ifclause != "") {
detach(star.data)
# no math operators (including < >) on factors.
# Should list all involved vars and convert them to copies, using as.numeric(levels(f))[f]
fz <- factorsNumeric(star.data)
sel <- fz[which(eval(parse(text=cmd$ifclause)))]
HTML.title(fz, HR=2)
HTML.title(sel,HR=2)
#attach(subset(star.data,eval(parse(text=cmd$ifclause))))
attach(star.data[sel])
}
}
}
# loads the script file, so that the function becomes available
# source(file=script)
retVal <- paste(retVal,readChar(script, file.info(script)$size),sep="\n")
# calls the function
# eval(parse(text=paste(command,"(cmd)")))
if (exists("cmd$ifclause")) {
if (cmd$ifclause != "") {
detach()
attach(star.data)
}
}
} else {
return(theLine)
}
return(retVal)
} else {
return(theLine)
}
return(theLine)
}
source <- star.source(star.cmdline)
source
#eval(parse(text=source))
